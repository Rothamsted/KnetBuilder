package net.sourceforge.ondex.rdf.export;

import java.util.Collection;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Stream;

import org.apache.commons.rdf.jena.JenaGraph;
import org.apache.jena.rdf.model.Model;
import org.apache.jena.rdf.model.ModelFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import info.marcobrandizi.rdfutils.jena.elt.RDFProcessor;
import info.marcobrandizi.rdfutils.namespaces.NamespaceUtils;
import net.sourceforge.ondex.core.ONDEXConcept;
import net.sourceforge.ondex.core.ONDEXGraph;
import net.sourceforge.ondex.core.ONDEXGraphMetaData;
import net.sourceforge.ondex.core.ONDEXRelation;
import net.sourceforge.ondex.rdf.export.mappers.RDFXFactory;

/**
 * The RDFExporter machinery. 
 * 
 * This triggers the exporting of an {@link ONDEXGraph}, passing it to the {@link RDFXFactory java2rdf-based RDF mappers}
 * and calling an handler parameter for the RDF chunks generated during the process.
 * 
 * The handler is supposed to do some concrete job, such as saving to a file or sending the RDF to a
 * triple store. 
 *
 * @author brandizi
 * <dl><dt>Date:</dt><dd>21 Nov 2017</dd></dl>
 *
 */
public class RDFExporter extends RDFProcessor<ONDEXGraph>
{
	@Override
	public final void process ( ONDEXGraph graph, Object...opts ) {
		this.export ( graph );
	}
	
	public void export ( ONDEXGraph graph )
	{
		RDFXFactory xfact = new RDFXFactory ( this.getDestinationSupplier ().get () );
		
		// TODO: Graph
		this.setDuplicateTBox ( true );
		final RDFXFactory xfactf = xfact; 
		ONDEXGraphMetaData metaData = graph.getMetaData ();
		Stream.of ( 
			metaData.getConceptClasses (), 
			metaData.getRelationTypes (), 
			metaData.getAttributeNames (), 
			metaData.getEvidenceTypes (),
			metaData.getUnits ()
		)
		.flatMap ( Collection::stream )
		.forEach ( meta -> xfactf.map ( meta ) );
								
		// We export all metadata in one chunk. This is typically small at this point and flushing it out 
		// allows a client to handle the whole T-Box first.
		xfact = this.handleNewXTask ( xfact, true );
		this.setDuplicateTBox ( false );
		
		for ( ONDEXConcept concept: graph.getConcepts () )
		{
			xfact.map ( concept );
			xfact = this.handleNewXTask ( xfact );
		}

		for ( ONDEXRelation relation: graph.getRelations () )
		{
			xfact.map ( relation );
			xfact = this.handleNewXTask ( xfact );
		}
		
		this.handleNewXTask ( xfact, true );
		
		ExecutorService executor = this.getExecutor ();
		
		executor.shutdown ();

		this.waitExecutor ( "Waiting for RDF export completion, please wait..." );
		log.info ( "...RDF export finished" );
	}
	
	private RDFXFactory handleNewXTask ( RDFXFactory xfact ) {
		return handleNewXTask ( xfact, false );
	}

	/**
	 * Wraps the model generated by {@link #getDestinationSupplier()} into a a new {@link RDFXFactory}, which 
	 * is the destination to which {@link #export(ONDEXGraph)} sends mappings instructions.
	 *  
	 */
	private RDFXFactory handleNewXTask ( RDFXFactory xfact, boolean forceFlush )
	{
		Model currentModel = xfact.getJenaModel ();
		Model newModel = super.handleNewTask ( currentModel , forceFlush );

		if ( currentModel == newModel ) return xfact;
		return new RDFXFactory ( newModel );
	}
}
